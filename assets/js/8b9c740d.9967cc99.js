"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3212],{131:(e,n,o)=>{o.d(n,{A:()=>a});o(8101);var t=o(3526);const r={tabItem:"tabItem_w3dh"};var s=o(5105);function a(e){let{children:n,hidden:o,className:a}=e;return(0,s.jsx)("div",{role:"tabpanel",className:(0,t.A)(r.tabItem,a),hidden:o,children:n})}},3331:(e,n,o)=>{o.d(n,{R:()=>a,x:()=>i});var t=o(8101);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}},5283:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>l,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"getting-started/core-concepts","title":"Core Concepts","description":"The sole purpose of this library is to make working with Node and Web Workers simpler and remove boilerplate code for common tasks.","source":"@site/docs/getting-started/core-concepts.md","sourceDirName":"getting-started","slug":"/getting-started/core-concepts","permalink":"/threadpool/docs/getting-started/core-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/pfaciana/threadpool/tree/master/docs/docs/getting-started/core-concepts.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"sidebar_label":"Core Concepts"},"sidebar":"tutorialSidebar","previous":{"title":"Installation","permalink":"/threadpool/docs/getting-started/installation"},"next":{"title":"API Reference","permalink":"/threadpool/docs/category/api-reference"}}');var r=o(5105),s=o(3331),a=o(7647),i=o(131);const l={sidebar_position:3,sidebar_label:"Core Concepts"},c="Core Concepts",d={},h=[{value:"Terms",id:"terms",level:2},{value:"Concepts",id:"concepts",level:2},{value:"Traditional Worker vs Worker Functions",id:"traditional-worker-vs-worker-functions",level:2},{value:"Traditional Worker",id:"traditional-worker",level:3},{value:"Server Worker Function",id:"server-worker-function",level:3},{value:"Web Worker Function",id:"web-worker-function",level:3},{value:"Common APIs",id:"common-apis",level:3},{value:"Adding Tasks",id:"adding-tasks",level:4},{value:"Events",id:"events",level:4},{value:"Callback Listeners",id:"callback-listeners",level:4},{value:"State Methods",id:"state-methods",level:4},{value:"Ways to make Traditional Workers",id:"ways-to-make-traditional-workers",level:2},{value:"enableExitEventFallback",id:"enableexiteventfallback",level:4},{value:"Ways to make Worker Functions",id:"ways-to-make-worker-functions",level:2},{value:"Comparison between <code>importWorker</code> types",id:"comparison-between-importworker-types",level:3},{value:"\ud83e\uddd9\u200d Magic Sorcery",id:"-magic-sorcery",level:2}];function u(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"core-concepts",children:"Core Concepts"})}),"\n",(0,r.jsx)(n.p,{children:'The sole purpose of this library is to make working with Node and Web Workers simpler and remove boilerplate code for common tasks.\nBecause Workers are, by nature, multi-threaded, we want a way to manage the code so it\'s non-blocking.\nA thread (or task) "pool" allows us to add worker threads without blocking the main thread.\nThen emitting events at different stages of the worker lifecycle is how we can take action in a non-blocking manner.\nThat is the core concept of this library.'}),"\n",(0,r.jsx)(n.h2,{id:"terms",children:"Terms"}),"\n",(0,r.jsxs)(n.p,{children:["At a high level, we'll use the terms ",(0,r.jsx)(n.code,{children:"worker"}),", ",(0,r.jsx)(n.code,{children:"thread"})," and ",(0,r.jsx)(n.code,{children:"task"})," to mean roughly the same thing, albeit in slightly different contexts.\nA quick summary on the basic difference:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.code,{children:"worker"})," will tend to refer to a node (or web) worker instance"]}),"\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.code,{children:"thread"})," will be our custom abstraction of a worker, with some added extras"]}),"\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.code,{children:"task"})," is a ",(0,r.jsx)(n.code,{children:"thread"})," (or a series of related ",(0,r.jsx)(n.code,{children:"thread"}),"s) within a ",(0,r.jsx)(n.code,{children:"pool"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Most of the time, a ",(0,r.jsx)(n.code,{children:"task"})," will only have one ",(0,r.jsx)(n.code,{children:"thread"}),", and because of that, we'll have some syntactic sugar to reduce user code"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["And finally for completeness, a ",(0,r.jsx)(n.code,{children:"pool"})," is just a collection of ",(0,r.jsx)(n.code,{children:"task"}),"s"]}),"\n",(0,r.jsx)(n.h2,{id:"concepts",children:"Concepts"}),"\n",(0,r.jsxs)(n.p,{children:["You can get both the status of a ",(0,r.jsx)(n.code,{children:"pool"})," or a ",(0,r.jsx)(n.code,{children:"thread"}),"."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.code,{children:"thread"})," status is just its state (i.e. ",(0,r.jsx)(n.code,{children:"ACTIVE"}),", ",(0,r.jsx)(n.code,{children:"ERROR"}),", ",(0,r.jsx)(n.code,{children:"COMPLETED"}),", etc.)"]}),"\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.code,{children:"pool"})," status is determined by the ",(0,r.jsx)(n.code,{children:"tasks"})," within it, grouped by properties like ",(0,r.jsx)(n.code,{children:"queued"}),", ",(0,r.jsx)(n.code,{children:"active"}),", ",(0,r.jsx)(n.code,{children:"remaining"}),", etc.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Remember a ",(0,r.jsx)(n.code,{children:"task"})," can have multiple ",(0,r.jsx)(n.code,{children:"thread"}),"s, so a ",(0,r.jsx)(n.code,{children:"task"})," can be ",(0,r.jsx)(n.code,{children:"active"})," if at least one ",(0,r.jsx)(n.code,{children:"thread"})," within it has started, but all ",(0,r.jsx)(n.code,{children:"threads"})," within it are not finished, etc."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"So, this is basically how you'll interact with the library."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Create a ",(0,r.jsx)(n.code,{children:"pool"})]}),"\n",(0,r.jsxs)(n.li,{children:["Import a ",(0,r.jsx)(n.code,{children:"worker"})," script OR a TypeScript/Javascript module as a ",(0,r.jsx)(n.code,{children:"worker"})," (more on this later)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["NOTE: This library automatically converts the ",(0,r.jsx)(n.code,{children:"worker"})," into a ",(0,r.jsx)(n.code,{children:"thread"})," for you"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Create a series of ",(0,r.jsx)(n.code,{children:"task"}),"s using those ",(0,r.jsx)(n.code,{children:"thread"}),"s"]}),"\n",(0,r.jsxs)(n.li,{children:["Add those ",(0,r.jsx)(n.code,{children:"task"}),"s to the ",(0,r.jsx)(n.code,{children:"pool"})]}),"\n",(0,r.jsxs)(n.li,{children:["Add event listeners to the ",(0,r.jsx)(n.code,{children:"pool"})," to handle the ",(0,r.jsx)(n.code,{children:"thread"})," lifecycle"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"traditional-worker-vs-worker-functions",children:"Traditional Worker vs Worker Functions"}),"\n",(0,r.jsx)(n.p,{children:'Originally this library was designed to create a pool for traditional node workers. However, after working with Go, I really like go routines and wanted to implement something similar to that in TypeScript/JavaScript. Obviously, JavaScript does not allow that type of implementation, but my goal was to have regular functions run on their own thread will very little effort. This will get explained later, but the purpose here is to introduce the two styles of "workers" this library supports.'}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'A "traditional" worker looks and acts like a Node worker (because it is under the hood)'}),"\n",(0,r.jsx)(n.li,{children:'A worker "function" is a go-like go routine that turns a function into a worker'}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:'These go routine like "functions" are available both on the server (Node/Bun/Deno) and in the browser.\nIf you see the terms "web" or "browser" that is talking about worker functions in the browser.\nIf you see the term "function" outside the context of "web" or "browser" that is talking about worker functions on the server. Otherwise, if you just see "worker" outside the context of a worker "function", we are talking about "traditional" workers.'}),"\n",(0,r.jsx)(n.h3,{id:"traditional-worker",children:"Traditional Worker"}),"\n",(0,r.jsx)(n.p,{children:"In its simplest form, here is how you would create a traditional worker:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { WorkerPool } from '@renderdev/threadpool/node'\n\n// Create a pool and import the worker script\nconst filename = new URL('./some-node-worker.ts', import.meta.url)\nconst pool = new WorkerPool(filename)\n\n// Listen for when all the tasks are completed\npool.allSettled(threads => console.log(`All ${threads.length} tasks completed`))\n\n// Create tasks by passing `workerData` to the worker \npool.addTask({ action: 'fibonacci', number: 42 })\n// ...some more tasks\npool.addTask({ action: 'tribonacci', number: 32 })\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"There are a lot more configurations and customizations you can do. This is just to get you started."})}),"\n",(0,r.jsx)(n.h3,{id:"server-worker-function",children:"Server Worker Function"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { FunctionPool, importTaskWorker } from '@renderdev/threadpool/function'\n\n// Import the types. Optional, but this gives us type checking\nimport type * as mathType from './math.ts'\n// Convert any module into a worker function (with type checking)\nconst filename = new URL('./math.ts', import.meta.url)\nconst { fibonacci, tribonacci } = await importTaskWorker<typeof mathType>(filename)\n\n// Create a pool\nconst pool = new FunctionPool()\n\n// Listen for when all the tasks are completed\npool.allSettled(threads => console.log(`All ${threads.length} tasks completed`))\n\n// Create tasks by converting the imported functions into threads that act as tasks\npool.addTask(fibonacci('42')) // Uh-oh! TS: fibonacci expects a number\n// ...some more tasks\npool.addTask(tribonacci(32))\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["Your IDE will catch ",(0,r.jsx)(n.code,{children:"pool.addTask(fibonacci('42'))"})," as a TS error because 42 should be a number, not a string"]})}),"\n",(0,r.jsx)(n.h3,{id:"web-worker-function",children:"Web Worker Function"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { WebFunctionPool, importTaskWebWorker } from '@renderdev/threadpool/web'\n\n// Import the types. Optional, but this gives us type checking\nimport type * as mathType from './math.ts'\n// Convert any module into a worker function (with type checking)\nconst filename = new URL('./math.ts', import.meta.url)\nconst { fibonacci, tribonacci } = await importTaskWebWorker<typeof mathType>(filename)\n\n// Create a pool\nconst pool = new WebFunctionPool()\n\n// Listen for when all the tasks are completed\npool.allSettled(threads => console.log(`All ${threads.length} tasks completed`))\n\n// Create tasks by converting the imported functions into threads that act as tasks\npool.addTask(fibonacci('42')) // Uh-oh! TS: fibonacci expects a number\n// ...some more tasks\npool.addTask(tribonacci(32))\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:'The Pool API, whether for "traditional" workers on the server, "function" workers on the server or "function" workers in the browser, is designed to be consistent.'})}),"\n",(0,r.jsx)(n.h3,{id:"common-apis",children:"Common APIs"}),"\n",(0,r.jsx)(n.p,{children:"You've probably noticed the code for all three worker pools are very similar. Here are some common API methods they all share."}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["We'll use the ",(0,r.jsx)(n.code,{children:"WorkerPool"})," for this example, but these methods are the same for ",(0,r.jsx)(n.code,{children:"FunctionPool"})," and ",(0,r.jsx)(n.code,{children:"WebFunctionPool"})]})}),"\n",(0,r.jsx)(n.h4,{id:"adding-tasks",children:"Adding Tasks"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const pool = new WorkerPool()\npool.addTask({ action: 'fibonacci', number: 42 }) // For traditional workers\npool.addTask(async () => await someThreadOrThreadsToRun()) // For worker functions (no syntactic sugar)\npool.addTask(someThreadOrThreadsToRun()) // For worker functions (with syntactic sugar)\n"})}),"\n",(0,r.jsx)(n.h4,{id:"events",children:"Events"}),"\n",(0,r.jsx)(n.p,{children:"You can certainly listen for events, but most of the time you'll use the handy callback listeners because they are a little more powerful.\nI'm adding this section first because the callback listeners are derived from these events."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const pool = new WorkerPool()\npool.on('worker.init', (thread) => {\n  // When any worker thread is initialized and starts execution.\n})\npool.on('worker.status', (status, newState, oldState, thread) => {\n  // When any worker thread's status changes.\n})\npool.on('worker.message', (data, thread) => {\n  // When any worker thread completes successfully with a result.\n})\npool.on('worker.messageerror', (error, thread) => {\n  // When any worker thread's promise rejects with an error.\n})\npool.on('worker.error', (error, thread) => {\n  // When any worker thread throws an error directly during execution.\n})\npool.on('worker.exit', (exitCode, thread) => {\n  // When any worker thread completes execution (either success or error).\n})\npool.on('complete', (exitCode, thread) => {\n  // When all tasks in the pool have completed.\n})\n"})}),"\n",(0,r.jsx)(n.h4,{id:"callback-listeners",children:"Callback Listeners"}),"\n",(0,r.jsx)(n.p,{children:"This is how you will listen for events most of the time."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const pool = new WorkerPool()\n\n// Listen for when something happens at a task level\npool.then((value: any, thread: WorkerThread) => {\n  // on 'worker.message'\n})\npool.catch((error: any, type: 'error' | 'messageerror', thread: WorkerThread) => {\n  // on 'worker.error' OR 'worker.messageerror'\n})\npool.finally((exitCode: any, thread: WorkerThread) => {\n  // on 'worker.exit'\n})\n\n// Listen for when something happens at a pool level\npool.allSettled((threads: WorkerThread[]) => {\n  // on 'complete'\n})\npool.all((threads: WorkerThread[]) => {\n  // on 'complete' OR first 'worker.error' OR first 'worker.messageerror'\n})\npool.any((threads: WorkerThread[]) => {\n  // on first 'worker.message' OR 'complete' when all threads failed\n})\npool.race((threads: WorkerThread[]) => {\n  // on first 'worker.message' OR first 'worker.error' OR first 'worker.messageerror'\n})\n"})}),"\n",(0,r.jsxs)(n.admonition,{type:"info",children:[(0,r.jsx)(n.p,{children:"If you've ever worked with JavaScript Promises, then these methods will look very familiar to you."}),(0,r.jsx)(n.p,{children:"This is how these method names were chosen."})]}),"\n",(0,r.jsx)(n.h4,{id:"state-methods",children:"State Methods"}),"\n",(0,r.jsx)(n.p,{children:"For getting the current state of a pool at any time"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const pool = new WorkerPool()\npool.isCompleted() as boolean\npool.hasAvailableThread() as boolean\npool.status(infoToGet, returnType) as returnType // Read docs for more info\n"})}),"\n",(0,r.jsx)(n.h2,{id:"ways-to-make-traditional-workers",children:"Ways to make Traditional Workers"}),"\n",(0,r.jsxs)(n.p,{children:["Making a traditional worker is very straightforward.\nYou probably guessed by looking at the example code that the signature is the same for a standard node worker, and you'd be right!\nHowever, there is one concept that may have been missed just by looking at the examples above.\nIt is actually just the ",(0,r.jsx)(n.em,{children:"default"})," configuration for subsequent workers. You can override this to allow for different worker threads all in the same pool. You can even set an empty string as the default worker, if you don't want it defined."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { WorkerPool } from '@renderdev/threadpool/node'\n\n// shorthand\nconst pool = new WorkerPool('./some-worker-file.ts', { env: process.env })\nconst fib = pool.addTask({ action: 'fibonacci', number: 42 })\nfib.then(value => console.log(value)).catch(error => console.error(error))\n\n// override the default worker\nconst poolNoDefault = new WorkerPool(``, {})\nconst trib = poolNoDefault.addWorker('./some-other-worker-file.js', {\n  workerData: { action: 'tribonacci', number: 32 },\n})\ntrib.then(value => console.log(value)).catch(error => console.error(error))\n"})}),"\n",(0,r.jsxs)(n.admonition,{type:"warning",children:[(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"addTask"})," method automatically inherits the default worker, and you pass the ",(0,r.jsx)(n.code,{children:"workerData"})," as the only argument."]}),(0,r.jsxs)(n.p,{children:["If you do decide to set an empty string as the default worker, then you can never use the ",(0,r.jsx)(n.code,{children:"addTask"})," method.\nThat's because, in that case, there is no worker to inherit."]})]}),"\n",(0,r.jsx)(n.h4,{id:"enableexiteventfallback",children:"enableExitEventFallback"}),"\n",(0,r.jsxs)(n.p,{children:["A quick note on the ",(0,r.jsx)(n.code,{children:"enableExitEventFallback"})," method. At the time of this writing ",(0,r.jsx)(n.code,{children:"Bun"})," and ",(0,r.jsx)(n.code,{children:"Deno"})," are still implementing full support for Node Worker Threads. This library is designed to work on all major JavaScript runtimes that support Node Worker Threads, including ",(0,r.jsx)(n.code,{children:"Bun"})," and ",(0,r.jsx)(n.code,{children:"Deno"}),". However they may implement features a little differently. So ",(0,r.jsx)(n.code,{children:"enableExitEventFallback"})," is an option to help keep those runtimes working consistently. This is an optional configuration, and I find currently ",(0,r.jsx)(n.code,{children:"Deno"})," is the most likely to need this. If you notice your connections are not closing properly, try setting this flag to ",(0,r.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { WorkerPool } from '@renderdev/threadpool/node'\n\nconst pool = new WorkerPool('./some-worker-file.ts')\nawait pool.enableExitEventFallback() // automatically detects if this is needed\nawait pool.enableExitEventFallback(true) // force the fallback on\nawait pool.enableExitEventFallback(false) // force the fallback off (this is the default)\n"})}),"\n",(0,r.jsxs)(n.admonition,{type:"warning",children:[(0,r.jsxs)(n.p,{children:["While allowing ",(0,r.jsx)(n.code,{children:"enableExitEventFallback"})," to automatically detect if the fallback is needed may sound good, there is a performance hit. So I would not recommend automatic detection, unless you are having issues otherwise."]}),(0,r.jsxs)(n.p,{children:["If you want to be safe, force it on with ",(0,r.jsx)(n.code,{children:"await pool.enableExitEventFallback(true)"}),". There is no performance hit this way."]}),(0,r.jsxs)(n.p,{children:["If you know you're only working in Node, then you may want to ignore calling ",(0,r.jsx)(n.code,{children:"enableExitEventFallback"}),"."]})]}),"\n",(0,r.jsx)(n.h2,{id:"ways-to-make-worker-functions",children:"Ways to make Worker Functions"}),"\n",(0,r.jsx)(n.p,{children:"The way we can convert a function into a worker automatically is by telling the pool how to import it. Then we can pass those instructions on to the worker file side of things. So the only real requirement is that the function we want to convert must be exported from a module. This means, in theory, we can take any JavaScript library and convert it into a worker function with no boilerplate setup."}),"\n",(0,r.jsx)(n.p,{children:"The way we achieve this is through three similar, but different functions."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"importTaskWorker"})," or ",(0,r.jsx)(n.code,{children:"importTaskWebWorker"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"importWorker"})," or ",(0,r.jsx)(n.code,{children:"importWebWorker"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"importPersistentWorker"})," or ",(0,r.jsx)(n.code,{children:"importPersistentWebWorker"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The simplest of the bunch is the ",(0,r.jsx)(n.code,{children:"importTaskWorker"})," (or ",(0,r.jsx)(n.code,{children:"importTaskWebWorker"})," for the browser).\nIt is nothing more than syntactic sugar for ",(0,r.jsx)(n.code,{children:"importWorker"})," (or ",(0,r.jsx)(n.code,{children:"importWebWorker"})," for the browser).\nUse ",(0,r.jsx)(n.code,{children:"importTaskWorker"})," when:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"You know you don't need a persistent connection to the worker left open"}),"\n",(0,r.jsx)(n.li,{children:"You know you're only calling the function directly and that is the entire purpose of the worker"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"If we know that, then we can wrap the worker function in a promise and return it. It's just shorthand for the most common use case."}),"\n",(0,r.jsxs)(n.p,{children:["Now that you know this, we can go over the other two functions: ",(0,r.jsx)(n.code,{children:"importWorker"})," and ",(0,r.jsx)(n.code,{children:"importPersistentWorker"}),".\nThe major difference, as probably guessed, is that one keeps the worker connection open and the other automatically closes it.\nSo if you use ",(0,r.jsx)(n.code,{children:"importPersistentWorker"}),", you are responsible for terminating the worker connection when you are done with it."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"importPersistentWorker"})," when you need the worker file to preserve state while you are working with it","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"This does, however, require the worker file to implement state management"}),"\n",(0,r.jsxs)(n.li,{children:["For this reason, an ",(0,r.jsx)(n.code,{children:"importPersistentWorker"})," is typically going to be used the least."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Let's jump to the code:"}),"\n",(0,r.jsxs)(n.h3,{id:"comparison-between-importworker-types",children:["Comparison between ",(0,r.jsx)(n.code,{children:"importWorker"})," types"]}),"\n",(0,r.jsx)(n.p,{children:"This is a basic example that demonstrates using all three with the same use case."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import {\n  FunctionPool,\n  importTaskWorker,\n  importWorker,\n  importPersistentWorker,\n} from '@renderdev/threadpool/function'\n// Used for type checking\nimport type * as mathType from './math.ts'\n\nconst filename = new URL('./math.ts', import.meta.url)\n\nconst pool = new FunctionPool()\n\n// Option 1\npool.addTask(async () => {\n  const persistentWorker = await importPersistentWorker<typeof mathType>(filename)\n  const result = await persistentWorker.fib(42)\n  // persistentWorker is still open, we can keep working with it\n  persistentWorker.terminate() // We are responsible for closing the connection\n  return result\n}, 'NOTE: Persistent')\n\n// Option 2\npool.addTask(async () => {\n  const simpleWorker = await importWorker<typeof mathType>(filename)\n  // simpleWorker is closed as soon as the function returns\n  return await simpleWorker.fib(42)\n}, 'NOTE: Simple')\n\n// Option 3\nconst taskWorker = await importTaskWorker<typeof mathType>(filename)\npool.addTask(taskWorker.fib(42), 'NOTE: Task')\n"})}),"\n",(0,r.jsx)(n.p,{children:"You can see that in this simple example:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"importTaskWorker"})," is just shorthand for ",(0,r.jsx)(n.code,{children:"importWorker"})]}),"\n",(0,r.jsxs)(n.li,{children:["and ",(0,r.jsx)(n.code,{children:"importWorker"})," is just shorthand for ",(0,r.jsx)(n.code,{children:"importPersistentWorker"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Each function's strength is introduced when the use case becomes more complex."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"importPersistentWorker"})," is the most flexible, but also the most complex and verbose"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"importTaskWorker"})," is the most simple, but also the least flexible"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"importWorker"})," is in the middle","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"It is the best option when you don't need to persist the worker connection, but you need to do more than just call the function"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsx)(n.p,{children:"Even though any function can be converted into a worker function, there's always a small chance it could cause potential side effects. Because we are importing that module on another thread, it will not have any context from the main thread. Keep this in mind if this could cause an issue with your code."})}),"\n",(0,r.jsx)(n.h2,{id:"-magic-sorcery",children:"\ud83e\uddd9\u200d Magic Sorcery"}),"\n",(0,r.jsx)(n.p,{children:"Anything that can be dynamically imported (which exports a property or function that returns a cloneable structured data) can be converted into a worker function.\nThis means we can convert any TS/JS file, third party libraries (like from NPM or JSR) or data urls, etc."}),"\n",(0,r.jsx)(n.p,{children:"Here is an additional example showing the use of popular third party libraries and custom inline data urls."}),"\n",(0,r.jsx)(n.p,{children:"All these tasks automatically run in parallel on their own thread!"}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(i.A,{value:"ts",label:"TypeScript",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { FunctionPool, importTaskWorker, importPersistentWorker, StatusType } from '@renderdev/threadpool'\n\n// Set up the pool\nconst pool = new FunctionPool()\npool.race((data, thread) => console.log(`Finished First: ${thread.meta} = ${data}\\n`))\npool.then((data, thread) => console.log(thread.meta, data))\npool.allSettled(() => console.log('\\nDONE!', pool.status('completed', StatusType.COUNT)))\n\n// Import the default export from the `@sindresorhus/slugify` package\ntype S = typeof import('@sindresorhus/slugify');\nconst { default: slugify } = await importTaskWorker<S>('@sindresorhus/slugify')\n\n// The `clamp` package returns a CommonJS module.exports\nconst { default: clamp } = await importTaskWorker('clamp')\n\n// Import a custom data url, where you inline the code with a data url\ntype W = {\n  helloWorld: () => string;\n  default: number;\n}\nconst { default: fortyTwo, helloWorld } = await importTaskWorker<W>(`data:text/javascript,\n  export const helloWorld = () => \"Hello, World!\";\t\n  export default 42;\n`)\n\npool.addTask(slugify(' \ud83d\udc36 goes WOOF! ', { customReplacements: [['\ud83d\udc36', 'dog']] }), 'slugify(\" \ud83d\udc36 goes WOOF! \")')\npool.addTask(clamp(1, 2, 3), 'clamp(1, 2, 3)')\npool.addTask(helloWorld(), 'helloWorld()')\npool.addTask(fortyTwo(), 'fortyTwo()')\npool.addTask(async () => {\n  // Import a custom data url, where you persist state\n  type C = {\n    counter: number;\n    count: () => number;\n    maybeCount: () => boolean;\n  }\n  const getRandomNumber = (): boolean => !!Math.round(Math.random())\n  const { counter, count, maybeCount, terminate } = await importPersistentWorker<C>(`data:text/javascript,\n    export let counter = 0;\t\n    export const count = () => counter+=1;\n    export const maybeCount = ${getRandomNumber.toString()};\n  `)\n  await count()\n  await count()\n  if (await maybeCount()) {\n    await count()\n  }\n  const result = await counter()\n  terminate()\n  return result\n}, 'Counted')\n"})})}),(0,r.jsx)(i.A,{value:"output",label:"Output",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'Finished First: clamp(1, 2, 3) = 2\n\nclamp(1, 2, 3) 2\nslugify(" \ud83d\udc36 goes WOOF! ") dog-goes-woof\nfortyTwo() 42\nhelloWorld() Hello, World!\nCounted 3 // or 2 because of `maybeCount`\n\nDONE! 5\n'})})})]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},7647:(e,n,o)=>{o.d(n,{A:()=>g});var t=o(8101),r=o(3526),s=o(5093),a=o(5234),i=o(2569),l=o(1390),c=o(7775),d=o(7623);function h(e){return t.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,t.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:n,children:o}=e;return(0,t.useMemo)((()=>{const e=n??function(e){return h(e).map((e=>{let{props:{value:n,label:o,attributes:t,default:r}}=e;return{value:n,label:o,attributes:t,default:r}}))}(o);return function(e){const n=(0,c.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,o])}function p(e){let{value:n,tabValues:o}=e;return o.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:o}=e;const r=(0,a.W6)(),s=function(e){let{queryString:n=!1,groupId:o}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!o)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return o??null}({queryString:n,groupId:o});return[(0,l.aZ)(s),(0,t.useCallback)((e=>{if(!s)return;const n=new URLSearchParams(r.location.search);n.set(s,e),r.replace({...r.location,search:n.toString()})}),[s,r])]}function k(e){const{defaultValue:n,queryString:o=!1,groupId:r}=e,s=u(e),[a,l]=(0,t.useState)((()=>function(e){let{defaultValue:n,tabValues:o}=e;if(0===o.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:o}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${o.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const t=o.find((e=>e.default))??o[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:s}))),[c,h]=m({queryString:o,groupId:r}),[k,f]=function(e){let{groupId:n}=e;const o=function(e){return e?`docusaurus.tab.${e}`:null}(n),[r,s]=(0,d.Dv)(o);return[r,(0,t.useCallback)((e=>{o&&s.set(e)}),[o,s])]}({groupId:r}),w=(()=>{const e=c??k;return p({value:e,tabValues:s})?e:null})();(0,i.A)((()=>{w&&l(w)}),[w]);return{selectedValue:a,selectValue:(0,t.useCallback)((e=>{if(!p({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);l(e),h(e),f(e)}),[h,f,s]),tabValues:s}}var f=o(3547);const w={tabList:"tabList_NQRc",tabItem:"tabItem_cMRk"};var x=o(5105);function b(e){let{className:n,block:o,selectedValue:t,selectValue:a,tabValues:i}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,s.a_)(),d=e=>{const n=e.currentTarget,o=l.indexOf(n),r=i[o].value;r!==t&&(c(n),a(r))},h=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const o=l.indexOf(e.currentTarget)+1;n=l[o]??l[0];break}case"ArrowLeft":{const o=l.indexOf(e.currentTarget)-1;n=l[o]??l[l.length-1];break}}n?.focus()};return(0,x.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":o},n),children:i.map((e=>{let{value:n,label:o,attributes:s}=e;return(0,x.jsx)("li",{role:"tab",tabIndex:t===n?0:-1,"aria-selected":t===n,ref:e=>{l.push(e)},onKeyDown:h,onClick:d,...s,className:(0,r.A)("tabs__item",w.tabItem,s?.className,{"tabs__item--active":t===n}),children:o??n},n)}))})}function y(e){let{lazy:n,children:o,selectedValue:s}=e;const a=(Array.isArray(o)?o:[o]).filter(Boolean);if(n){const e=a.find((e=>e.props.value===s));return e?(0,t.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,x.jsx)("div",{className:"margin-top--md",children:a.map(((e,n)=>(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==s})))})}function j(e){const n=k(e);return(0,x.jsxs)("div",{className:(0,r.A)("tabs-container",w.tabList),children:[(0,x.jsx)(b,{...n,...e}),(0,x.jsx)(y,{...n,...e})]})}function g(e){const n=(0,f.A)();return(0,x.jsx)(j,{...e,children:h(e.children)},String(n))}}}]);