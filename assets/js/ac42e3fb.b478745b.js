"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7194],{3331:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>i});var t=r(8101);const s={},a=t.createContext(s);function l(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(a.Provider,{value:n},e.children)}},4783:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"api/function/function-thread","title":"FunctionThread","description":"Manages a function-based thread with state tracking and event handling.","source":"@site/docs/api/function/function-thread.md","sourceDirName":"api/function","slug":"/api/function/function-thread","permalink":"/threadpool/docs/api/function/function-thread","draft":false,"unlisted":false,"editUrl":"https://github.com/pfaciana/threadpool/tree/master/docs/docs/api/function/function-thread.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Function API","permalink":"/threadpool/docs/category/function-api"},"next":{"title":"FunctionPool","permalink":"/threadpool/docs/api/function/function-pool"}}');var s=r(5105),a=r(3331);const l={sidebar_position:1},i="FunctionThread",d={},c=[{value:"Types",id:"types",level:2},{value:"FunctionThreadOptions",id:"functionthreadoptions",level:3},{value:"Properties",id:"properties",level:2},{value:"status",id:"status",level:3},{value:"message",id:"message",level:3},{value:"error",id:"error",level:3},{value:"meta",id:"meta",level:3},{value:"Methods",id:"methods",level:2},{value:"constructor",id:"constructor",level:3},{value:"Parameters",id:"parameters",level:4},{value:"Example",id:"example",level:4},{value:"start",id:"start",level:3},{value:"Returns",id:"returns",level:4},{value:"Example",id:"example-1",level:4},{value:"then",id:"then",level:3},{value:"Parameters",id:"parameters-1",level:4},{value:"Returns",id:"returns-1",level:4},{value:"Example",id:"example-2",level:4},{value:"catch",id:"catch",level:3},{value:"Parameters",id:"parameters-2",level:4},{value:"Returns",id:"returns-2",level:4},{value:"Example",id:"example-3",level:4},{value:"finally",id:"finally",level:3},{value:"Parameters",id:"parameters-3",level:4},{value:"Returns",id:"returns-3",level:4},{value:"Example",id:"example-4",level:4},{value:"Events",id:"events",level:2},{value:"init",id:"init",level:3},{value:"message",id:"message-1",level:3},{value:"error",id:"error-1",level:3},{value:"messageerror",id:"messageerror",level:3},{value:"exit",id:"exit",level:3},{value:"status",id:"status-1",level:3},{value:"Example",id:"example-5",level:4}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"functionthread",children:"FunctionThread"})}),"\n",(0,s.jsx)(n.p,{children:"Manages a function-based thread with state tracking and event handling."}),"\n",(0,s.jsx)(n.p,{children:"FunctionThread wraps an asynchronous function with thread-like status tracking and event capabilities, allowing it to be managed similar to actual worker threads but without the overhead of creating separate worker processes."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// Create a thread to perform a calculation\nconst thread = new FunctionThread({\n  workerFn: async () => {\n    // This simulates some complex time consuming work\n    await new Promise(resolve => setTimeout(resolve, 5000));\n    return 42;\n  },\n  meta: { id: \"calculation-1\" }\n});\n\n// Listen for events\nthread.on('message', (data) => {\n  console.log('Result:', data);\n});\n\n// Start the thread\nthread.start();\n\n// Or use Promise-like API\nthread.then(result => {\n  console.log('Got result:', result);\n}).catch((error, type) => {\n  console.error(`Error (${type}):`, error);\n}).finally(() => {\n  console.log('Thread completed');\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"types",children:"Types"}),"\n",(0,s.jsx)(n.h3,{id:"functionthreadoptions",children:"FunctionThreadOptions"}),"\n",(0,s.jsx)(n.p,{children:"Options for creating a FunctionThread instance."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"type FunctionThreadOptions = {\n  workerFn: () => Promise<any>;\n  meta?: any;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"properties",children:"Properties"}),"\n",(0,s.jsx)(n.h3,{id:"status",children:"status"}),"\n",(0,s.jsx)(n.p,{children:"Gets the current thread status."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"get status(): ThreadStatus\n"})}),"\n",(0,s.jsx)(n.h3,{id:"message",children:"message"}),"\n",(0,s.jsx)(n.p,{children:"Gets the latest message received from the thread (the function return value)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"get message(): any\n"})}),"\n",(0,s.jsx)(n.h3,{id:"error",children:"error"}),"\n",(0,s.jsx)(n.p,{children:"Gets any error that occurred in the thread."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"get error(): any\n"})}),"\n",(0,s.jsx)(n.h3,{id:"meta",children:"meta"}),"\n",(0,s.jsx)(n.p,{children:"Optional metadata associated with this thread."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"meta: any | undefined\n"})}),"\n",(0,s.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,s.jsx)(n.h3,{id:"constructor",children:"constructor"}),"\n",(0,s.jsx)(n.p,{children:"Creates a new FunctionThread."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"constructor(options: FunctionThreadOptions)\n"})}),"\n",(0,s.jsx)(n.h4,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"options"}),": Configuration options containing the worker function to execute and optional metadata"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'const thread = new FunctionThread({\n  workerFn: async () => {\n    const result = await complexCalculation();\n    return result;\n  },\n  meta: { id: "task-123", priority: "high" }\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"start",children:"start"}),"\n",(0,s.jsx)(n.p,{children:"Starts execution of the thread function. Once started, the thread cannot be started again."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"start(): boolean\n"})}),"\n",(0,s.jsx)(n.p,{children:"Events emitted during execution:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"'init' - When the thread starts"}),"\n",(0,s.jsx)(n.li,{children:"'message' - When the thread completes successfully"}),"\n",(0,s.jsx)(n.li,{children:"'error' - When the thread throws an error directly"}),"\n",(0,s.jsx)(n.li,{children:"'messageerror' - When the thread's promise rejects"}),"\n",(0,s.jsx)(n.li,{children:"'exit' - When the thread completes (either success or error)"}),"\n",(0,s.jsx)(n.li,{children:"'status' - When the thread status changes"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"returns",children:"Returns"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"boolean"}),": True if the thread was started, false if it was already running"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"example-1",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const thread = new FunctionThread({\n  workerFn: async () => {\n    return await fetchData();\n  }\n});\n\nthread.on('message', (data) => {\n  // Process the fetched data\n});\n\nthread.start();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"then",children:"then"}),"\n",(0,s.jsx)(n.p,{children:"Adds a callback to handle successful completion of the thread."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"then(onFulfilled: (value: any) => any): this\n"})}),"\n",(0,s.jsx)(n.h4,{id:"parameters-1",children:"Parameters"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"onFulfilled"}),": Function called with the result when thread completes successfully"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"returns-1",children:"Returns"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"This instance for chaining"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"example-2",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const thread = new FunctionThread({\n  workerFn: async () => {\n    return 42;\n  }\n});\n\nthread.then(result => {\n  console.log(`The answer is: ${result}`);\n});\n\nthread.start();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"catch",children:"catch"}),"\n",(0,s.jsx)(n.p,{children:"Adds a callback to handle errors from the thread."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"catch(onRejected: (error: any, type: 'error' | 'messageerror') => any): this\n"})}),"\n",(0,s.jsx)(n.h4,{id:"parameters-2",children:"Parameters"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"onRejected"}),": Function called when the thread encounters an error"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"returns-2",children:"Returns"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"This instance for chaining"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"example-3",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'const thread = new FunctionThread({\n  workerFn: async () => {\n    throw new Error("Something went wrong");\n  }\n});\n\nthread.catch((error, type) => {\n  console.error(`Error type: ${type}`);\n  console.error(error);\n});\n\nthread.start();\n'})}),"\n",(0,s.jsx)(n.h3,{id:"finally",children:"finally"}),"\n",(0,s.jsx)(n.p,{children:"Adds a callback that will be called when the thread exits, regardless of success or failure."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"finally(onFinally: () => void): this\n"})}),"\n",(0,s.jsx)(n.h4,{id:"parameters-3",children:"Parameters"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"onFinally"}),": Function called when the thread exits"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"returns-3",children:"Returns"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"This instance for chaining"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"example-4",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const thread = new FunctionThread({\n  workerFn: async () => {\n    // Some work\n  }\n});\n\nthread.finally(() => {\n  console.log('Thread finished, clean up resources');\n});\n\nthread.start();\n"})}),"\n",(0,s.jsx)(n.h2,{id:"events",children:"Events"}),"\n",(0,s.jsx)(n.p,{children:"The FunctionThread class emits the following events:"}),"\n",(0,s.jsx)(n.h3,{id:"init",children:"init"}),"\n",(0,s.jsx)(n.p,{children:"When the thread is initialized and starts execution."}),"\n",(0,s.jsx)(n.h3,{id:"message-1",children:"message"}),"\n",(0,s.jsx)(n.p,{children:"When the thread completes successfully with a result."}),"\n",(0,s.jsx)(n.h3,{id:"error-1",children:"error"}),"\n",(0,s.jsx)(n.p,{children:"When the thread throws an error directly during execution."}),"\n",(0,s.jsx)(n.h3,{id:"messageerror",children:"messageerror"}),"\n",(0,s.jsx)(n.p,{children:"When the thread's promise rejects with an error."}),"\n",(0,s.jsx)(n.h3,{id:"exit",children:"exit"}),"\n",(0,s.jsx)(n.p,{children:"When the thread completes execution (either success or error)."}),"\n",(0,s.jsx)(n.h3,{id:"status-1",children:"status"}),"\n",(0,s.jsx)(n.p,{children:"When the thread status changes."}),"\n",(0,s.jsx)(n.h4,{id:"example-5",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const thread = new FunctionThread({\n  workerFn: async () => {\n    return await processData();\n  }\n});\n\nthread.on('init', () => {\n  console.log('Thread started processing');\n});\n\nthread.on('message', (result) => {\n  console.log('Processing complete:', result);\n});\n\nthread.on('error', (error) => {\n  console.error('Processing error:', error);\n});\n\nthread.on('exit', (exitCode) => {\n  console.log(`Thread exited with code: ${exitCode}`);\n});\n\nthread.on('status', (status, newState, oldState) => {\n  console.log(`Status changed from ${oldState} to ${newState}`);\n});\n\nthread.start();\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}}}]);