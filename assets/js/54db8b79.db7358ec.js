"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8844],{3331:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>i});var t=r(8101);const a={},s=t.createContext(a);function l(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),t.createElement(s.Provider,{value:n},e.children)}},5712:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"api/web/function-thread","title":"WebFunctionThread","description":"Manages a function-based thread in web environments. WebFunctionThread wraps an asynchronous function with thread-like status tracking and eventing capabilities, allowing it to be managed similar to actual web workers but without the overhead of creating separate worker threads.","source":"@site/docs/api/web/function-thread.md","sourceDirName":"api/web","slug":"/api/web/function-thread","permalink":"/threadpool/docs/api/web/function-thread","draft":false,"unlisted":false,"editUrl":"https://github.com/pfaciana/threadpool/tree/master/docs/docs/api/web/function-thread.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Web API","permalink":"/threadpool/docs/category/web-api"},"next":{"title":"WebFunctionPool","permalink":"/threadpool/docs/api/web/function-pool"}}');var a=r(5105),s=r(3331);const l={sidebar_position:1},i="WebFunctionThread",d={},c=[{value:"Types",id:"types",level:2},{value:"WebFunctionThreadOptions",id:"webfunctionthreadoptions",level:3},{value:"Properties",id:"properties",level:2},{value:"status",id:"status",level:3},{value:"message",id:"message",level:3},{value:"error",id:"error",level:3},{value:"meta",id:"meta",level:3},{value:"Methods",id:"methods",level:2},{value:"constructor",id:"constructor",level:3},{value:"Parameters",id:"parameters",level:4},{value:"Example",id:"example",level:4},{value:"start",id:"start",level:3},{value:"Returns",id:"returns",level:4},{value:"then",id:"then",level:3},{value:"Parameters",id:"parameters-1",level:4},{value:"Returns",id:"returns-1",level:4},{value:"Example",id:"example-1",level:4},{value:"catch",id:"catch",level:3},{value:"Parameters",id:"parameters-2",level:4},{value:"Returns",id:"returns-2",level:4},{value:"Example",id:"example-2",level:4},{value:"finally",id:"finally",level:3},{value:"Parameters",id:"parameters-3",level:4},{value:"Returns",id:"returns-3",level:4},{value:"Example",id:"example-3",level:4},{value:"Events",id:"events",level:2},{value:"init",id:"init",level:3},{value:"message",id:"message-1",level:3},{value:"error",id:"error-1",level:3},{value:"messageerror",id:"messageerror",level:3},{value:"exit",id:"exit",level:3},{value:"status",id:"status-1",level:3}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"webfunctionthread",children:"WebFunctionThread"})}),"\n",(0,a.jsx)(n.p,{children:"Manages a function-based thread in web environments. WebFunctionThread wraps an asynchronous function with thread-like status tracking and eventing capabilities, allowing it to be managed similar to actual web workers but without the overhead of creating separate worker threads."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"// Create a thread to perform a calculation\nconst thread = new WebFunctionThread({\n  workerFn: async () => {\n    // Simulate complex work\n    await new Promise(resolve => setTimeout(resolve, 500));\n    return 42;\n  },\n  meta: { id: \"calculation-1\" }\n});\n\n// Listen for events\nthread.addEventListener('message', (event) => {\n  console.log('Result:', event.detail);\n});\n\n// Start the thread\nthread.start();\n\n// Or use Promise-like API\nthread.then(result => {\n  console.log('Got result:', result);\n}).catch((error, type) => {\n  console.error(`Error (${type}):`, error);\n}).finally(() => {\n  console.log('Thread completed');\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"types",children:"Types"}),"\n",(0,a.jsx)(n.h3,{id:"webfunctionthreadoptions",children:"WebFunctionThreadOptions"}),"\n",(0,a.jsx)(n.p,{children:"Options for creating a WebFunctionThread instance."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"type WebFunctionThreadOptions = {\n  workerFn: () => Promise<any>;  // The async function to execute in the thread\n  meta?: any;                    // Optional metadata to associate with the thread\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"properties",children:"Properties"}),"\n",(0,a.jsx)(n.h3,{id:"status",children:"status"}),"\n",(0,a.jsx)(n.p,{children:"Gets the current thread status."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"get status(): ThreadStatus\n"})}),"\n",(0,a.jsx)(n.h3,{id:"message",children:"message"}),"\n",(0,a.jsx)(n.p,{children:"Gets the latest message received from the thread."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"get message(): any\n"})}),"\n",(0,a.jsx)(n.h3,{id:"error",children:"error"}),"\n",(0,a.jsx)(n.p,{children:"Gets any error that occurred in the thread."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"get error(): any\n"})}),"\n",(0,a.jsx)(n.h3,{id:"meta",children:"meta"}),"\n",(0,a.jsx)(n.p,{children:"Optional metadata associated with this thread."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"meta: any | undefined\n"})}),"\n",(0,a.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,a.jsx)(n.h3,{id:"constructor",children:"constructor"}),"\n",(0,a.jsx)(n.p,{children:"Creates a new WebFunctionThread."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"constructor({ workerFn, meta }: WebFunctionThreadOptions)\n"})}),"\n",(0,a.jsx)(n.h4,{id:"parameters",children:"Parameters"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"options"}),": Configuration options containing the worker function to execute and optional metadata"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"// Create a thread to perform a calculation\nconst thread = new WebFunctionThread({\n  workerFn: async () => {\n    // Simulate complex work\n    await new Promise(resolve => setTimeout(resolve, 500))\n    return 42\n  },\n  meta: { id: 'calculation-1' },\n})\n"})}),"\n",(0,a.jsx)(n.h3,{id:"start",children:"start"}),"\n",(0,a.jsx)(n.p,{children:"Starts execution of the thread function. Once started, the thread cannot be started again."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"start(): boolean\n"})}),"\n",(0,a.jsx)(n.h4,{id:"returns",children:"Returns"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"boolean"}),": True if the thread was started, false if it was already running"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"then",children:"then"}),"\n",(0,a.jsx)(n.p,{children:"Adds a callback to handle successful completion of the thread."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"then(onFulfilled: (value: any) => any): this\n"})}),"\n",(0,a.jsx)(n.h4,{id:"parameters-1",children:"Parameters"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"onFulfilled"}),": Function called with the result when thread completes successfully"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"returns-1",children:"Returns"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"This instance for chaining"}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"example-1",children:"Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const thread = new WebFunctionThread({\n  workerFn: async () => {\n    return 42\n  },\n})\n\nthread.then(result => {\n  console.log(`The answer is: ${result}`)\n})\n\nthread.start()\n"})}),"\n",(0,a.jsx)(n.h3,{id:"catch",children:"catch"}),"\n",(0,a.jsx)(n.p,{children:"Adds a callback to handle errors from the thread."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"catch(onRejected: (reason: any, type: 'error' | 'messageerror') => any): this\n"})}),"\n",(0,a.jsx)(n.h4,{id:"parameters-2",children:"Parameters"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"onRejected"}),": Function called when the thread encounters an error"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"returns-2",children:"Returns"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"This instance for chaining"}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"example-2",children:"Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const thread = new WebFunctionThread({\n  workerFn: async () => {\n    throw new Error('Something went wrong')\n  },\n})\n\nthread.catch((error, type) => {\n  console.error(`Error type: ${type}`)\n  console.error(error)\n})\n\nthread.start()\n"})}),"\n",(0,a.jsx)(n.h3,{id:"finally",children:"finally"}),"\n",(0,a.jsx)(n.p,{children:"Adds a callback that will be called when the thread exits, regardless of success or failure."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"finally(onFinally: () => void): this\n"})}),"\n",(0,a.jsx)(n.h4,{id:"parameters-3",children:"Parameters"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"onFinally"}),": Function called when the thread exits"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"returns-3",children:"Returns"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"This instance for chaining"}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"example-3",children:"Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const thread = new WebFunctionThread({\n  workerFn: async () => {\n    // Some work\n  },\n})\n\nthread.finally(() => {\n  console.log('Thread finished, clean up resources')\n})\n\nthread.start()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"events",children:"Events"}),"\n",(0,a.jsx)(n.p,{children:"Events dispatched during execution:"}),"\n",(0,a.jsx)(n.h3,{id:"init",children:"init"}),"\n",(0,a.jsx)(n.p,{children:"When the thread starts"}),"\n",(0,a.jsx)(n.h3,{id:"message-1",children:"message"}),"\n",(0,a.jsx)(n.p,{children:"When the thread completes successfully"}),"\n",(0,a.jsx)(n.h3,{id:"error-1",children:"error"}),"\n",(0,a.jsx)(n.p,{children:"When the thread throws an error directly"}),"\n",(0,a.jsx)(n.h3,{id:"messageerror",children:"messageerror"}),"\n",(0,a.jsx)(n.p,{children:"When the thread's promise rejects"}),"\n",(0,a.jsx)(n.h3,{id:"exit",children:"exit"}),"\n",(0,a.jsx)(n.p,{children:"When the thread completes (either success or error)"}),"\n",(0,a.jsx)(n.h3,{id:"status-1",children:"status"}),"\n",(0,a.jsx)(n.p,{children:"When the thread status changes"})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}}}]);