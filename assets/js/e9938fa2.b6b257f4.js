"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6682],{365:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>c,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"examples/function/pool","title":"Multiple Workers","description":"1# Multiple Workers","source":"@site/docs/examples/function/pool.md","sourceDirName":"examples/function","slug":"/examples/function/pool","permalink":"/threadpool/docs/examples/function/pool","draft":false,"unlisted":false,"editUrl":"https://github.com/pfaciana/threadpool/tree/master/docs/docs/examples/function/pool.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Multiple Workers"},"sidebar":"tutorialSidebar","previous":{"title":"Basic Worker","permalink":"/threadpool/docs/examples/function/math"},"next":{"title":"Persistent Workers","permalink":"/threadpool/docs/examples/function/persistent-worker"}}');var s=n(5105),a=n(3331);const r={sidebar_position:2,title:"Multiple Workers"},c=void 0,i={},l=[{value:"Code",id:"code",level:2},{value:"Output",id:"output",level:2}];function d(e){const t={admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"1# Multiple Workers"}),"\n",(0,s.jsxs)(t.p,{children:["This example demonstrates how to use the ",(0,s.jsx)(t.code,{children:"FunctionPool"})," to manage concurrent tasks with both ",(0,s.jsx)(t.code,{children:"importTaskWorker"})," and ",(0,s.jsx)(t.code,{children:"importWorker"})," approaches, showing the different ways to execute functions in worker threads."]}),"\n",(0,s.jsx)(t.h2,{id:"code",children:"Code"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"import { setTimeout } from 'node:timers'\nimport { URL } from 'node:url'\nimport { FunctionPool, importTaskWorker, importWorker, StatusType } from '@renderdev/threadpool/function'\nimport type * as mathType from './math.ts'\n\nexport const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))\n\nconst start = performance.now()\n\nconst pool = (new FunctionPool({ poolSize: 15 }))\n  .allSettled(() => {\n    const completed = pool.status('completed', StatusType.RAW)\n\n    for (const thread of completed) {\n      console.log(thread.message, thread.status.SUCCESS ? 'Success' : 'Error', thread.meta)\n    }\n\n    console.log('\\nDONE!', pool.status('completed', StatusType.COUNT))\n    console.log('\\n\\nScript runtime: ' + (Math.round(performance.now() - start) / 1000) + ' sec\\n\\n')\n  })\n\nconst filename = new URL('./math.ts', import.meta.url)\n// Using importTaskWorker for pre-bound functions\nconst { add, fib, getState, state } = await importTaskWorker<typeof mathType>(filename)\n\npool.addTask(fib('42'), { meta: 1 }) // Intentional TS error to show IDEs can stil do type checking\npool.addTask(fib(42), { meta: 2 })\npool.addTask(fib(42), { meta: 3 })\npool.addTask(fib(42), { meta: 4 })\npool.addTask(fib(42), { meta: 5 })\n\n// Using importWorker for function references\nconst { fib: fib2 } = await importWorker<typeof mathType>(filename)\n\npool.addTask(() => fib2('42'), { meta: 11 }) // Intentional TS error to show IDEs can stil do type checking\npool.addTask(() => fib2(42), { meta: 21 })\npool.addTask(() => fib2(42), { meta: 31 })\nawait delay(2000)\npool.addTask(() => fib2(42), { meta: 41 })\npool.addTask(() => fib2(42), { meta: 51 })\n"})}),"\n",(0,s.jsx)(t.h2,{id:"output",children:"Output"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"267914296 Success { meta: 1 }\n267914296 Success { meta: 2 }\n267914296 Success { meta: 3 }\n267914296 Success { meta: 4 }\n267914296 Success { meta: 5 }\n267914296 Success { meta: 11 }\n267914296 Success { meta: 21 }\n267914296 Success { meta: 31 }\n\nDONE! 8\n\n\nScript runtime: 2.179 sec\n\n\n267914296 Success { meta: 1 }\n267914296 Success { meta: 2 }\n267914296 Success { meta: 3 }\n267914296 Success { meta: 4 }\n267914296 Success { meta: 5 }\n267914296 Success { meta: 11 }\n267914296 Success { meta: 21 }\n267914296 Success { meta: 31 }\n267914296 Success { meta: 41 }\n267914296 Success { meta: 51 }\n\nDONE! 10\n\n\nScript runtime: 4.222 sec\n"})}),"\n",(0,s.jsxs)(t.admonition,{type:"warning",children:[(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"await delay(2000)"})," used in this example, means the ",(0,s.jsx)(t.code,{children:"FunctionPool"})," will run the ",(0,s.jsx)(t.code,{children:"allSettled"})," callback (triggered from the emitted ",(0,s.jsx)(t.code,{children:"complete"})," event) twice. This is because all tasks have completed and the pool is not aware future tasks will be added. Then when future tasks are added, and completed again, it will trigger the ",(0,s.jsx)(t.code,{children:"allSettled"})," callback again."]}),(0,s.jsxs)(t.p,{children:["This is by design because it allows for full customization. The example output looks this way because  ",(0,s.jsx)(t.code,{children:"allSettled"})," was defined as soon as the ",(0,s.jsx)(t.code,{children:"FuntionPool"})," was created. You can change the position ",(0,s.jsx)(t.code,{children:"allSettled"})," is set OR use the ",(0,s.jsx)(t.code,{children:"meta"})," property to customize this exactly how you want."]})]})]})}function p(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},3331:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>c});var o=n(8101);const s={},a=o.createContext(s);function r(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(a.Provider,{value:t},e.children)}}}]);